#include "cryptopals_common.h"

unsigned char rcon[256] = {
    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 
    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 
    0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 
    0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 
    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 
    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 
    0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 
    0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 
    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 
    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 
    0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 
    0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 
    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 
    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 
    0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 
    0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
};

unsigned char s[256] = {
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
};

unsigned char inv_s[256] = {
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
};

byte inline getByteFromState (const byte* state, size_t row, size_t col) {
  return state[(col*4)+row];
}

void inline setByteInState (byte* state, size_t row, size_t col, byte value) {
  state[(col*4)+row] = value;
}

void showStateWithMoreIndent (const byte* state) {
  indent++;
  for (size_t row = 0; row < 4; row++) {
    PAD
    for (size_t col = 0; col < 4; col++)
      printf("%02x%s", getByteFromState(state, row, col), (col==3)?"\n":" ");
  }
  indent--;
}

uint32_t inline rotate (uint32_t n) {
  return ((n&0b11111111000000000000000000000000)>>24)|(n<<8);
}

uint32_t keyScheduleCore(uint32_t n, size_t i) {
  n = rotate(n);
  byte n0 = s[(n & 0xff000000) >> 24],
       n1 = s[(n & 0x00ff0000) >> 16],
       n2 = s[(n & 0x0000ff00) >> 8 ],
       n3 = s[(n & 0x000000ff) >> 0 ];
  n0 ^= rcon[i];
  n ^= n;
  n += (n0 << 24);
  n += (n1 << 16);
  n += (n2 << 8);
  n += (n3 << 0);
  return n;
}

byte* expandKey (const byte* key, size_t kn) {
  //KeyExpansions - Derive round key
  //Implemented from the following reference: en.wikipedia.org/wiki/Rijndael_key_schedule
  uint32_t* expandedKey;
  byte* expandedKeyBytes;
  size_t curLengthOfExpandedKeyInBytes = 0;
  size_t curLengthOfExpandedKeyIn32Words = 0;
  {
    //128-bit->176, 192-bit->208, 256-bit->240
    size_t b = (kn==16)?176:((kn==24)?208:240);
    expandedKey = (uint32_t*)malloc(sizeof(uint32_t)*(b/4));
    expandedKeyBytes = (byte*)malloc(sizeof(byte)*b);
    //The first n bytes of the expanded key the encryption key.
    for (size_t bi = 0, eki = 0; bi < kn; bi+=4, eki++) {
      byte b0 = key[bi+0],
           b1 = key[bi+1],
           b2 = key[bi+2],
           b3 = key[bi+3];
      uint32_t b = 0;
      b += b0 << 24;
      b += b1 << 16;
      b += b2 << 8;
      b += b3 << 0;
      expandedKey[eki] = b;
      curLengthOfExpandedKeyInBytes += 4;
      curLengthOfExpandedKeyIn32Words += 1;
    }
    
    int rcon_iteration_value = 1;
    
    while (curLengthOfExpandedKeyInBytes < b) {
      //Create 4 bytes:
      {
        uint32_t t = expandedKey[curLengthOfExpandedKeyIn32Words-1];
        t = keyScheduleCore(t, rcon_iteration_value++);
        uint32_t a = expandedKey[curLengthOfExpandedKeyIn32Words-(kn/4)];
        expandedKey[curLengthOfExpandedKeyIn32Words] = t^a;
        curLengthOfExpandedKeyInBytes+=4;
        curLengthOfExpandedKeyIn32Words+=1;
      }
      
      //Create 12 bytes:
      for (size_t toThree = 0; toThree < 3; toThree++) {
        uint32_t t = expandedKey[curLengthOfExpandedKeyIn32Words-1];
        uint32_t a = expandedKey[curLengthOfExpandedKeyIn32Words-(kn/4)];
        expandedKey[curLengthOfExpandedKeyIn32Words] = t^a;
        curLengthOfExpandedKeyInBytes+=4;
        curLengthOfExpandedKeyIn32Words+=1;
      }
      
      //Create 0, or 4 bytes:
      if ((kn*8) == 256 && (curLengthOfExpandedKeyInBytes != b)) {
        uint32_t t = expandedKey[curLengthOfExpandedKeyIn32Words-1];
        byte t0,t1,t2,t3;
        t0 = s[(t & 0xFF000000)>>24];
        t1 = s[(t & 0x00FF0000)>>16];
        t2 = s[(t & 0x0000FF00)>>8];
        t3 = s[(t & 0x000000FF)>>0];
        t = 0;
        t += (t0 << 24);
        t += (t1 << 16);
        t += (t2 << 8);
        t += (t3 << 0);
        uint32_t a = expandedKey[curLengthOfExpandedKeyIn32Words-(kn/4)];
        expandedKey[curLengthOfExpandedKeyIn32Words] = t^a;
        curLengthOfExpandedKeyInBytes+=4;
        curLengthOfExpandedKeyIn32Words+=1;
      }
      
      //Create 0, 8, or 12 bytes:
      if (((kn*8) != 128) && (curLengthOfExpandedKeyInBytes != b)) {
        size_t reps= ((kn*8) == 192)?2:3;
        for (size_t foo = 0; foo < reps; foo++) {
          uint32_t t = expandedKey[curLengthOfExpandedKeyIn32Words-1];
          uint32_t a = expandedKey[curLengthOfExpandedKeyIn32Words-(kn/4)];
          expandedKey[curLengthOfExpandedKeyIn32Words] = t^a;
          curLengthOfExpandedKeyInBytes+=4;
          curLengthOfExpandedKeyIn32Words+=1;
        }
      }
    }
  }
  
  for (size_t i = 0; i < curLengthOfExpandedKeyIn32Words; i++) {
    uint32_t ui32 = expandedKey[i];
    expandedKeyBytes[(i*4)+0] = (ui32 & 0xFF000000)>>24;
    expandedKeyBytes[(i*4)+1] = (ui32 & 0x00FF0000)>>16;
    expandedKeyBytes[(i*4)+2] = (ui32 & 0x0000FF00)>>8;
    expandedKeyBytes[(i*4)+3] = (ui32 & 0x000000FF)>>0;
  }
  
  PAD printf("Expanded Key:\n");
  for (size_t i = 0; i < curLengthOfExpandedKeyInBytes; i+=16) {
    showStateWithMoreIndent(expandedKeyBytes+i);
    if (i != (curLengthOfExpandedKeyInBytes-16))
      printf("\n");
  }
  
  free(expandedKey);
  return expandedKeyBytes;
}

void addRoundKey(byte* state, const byte* roundKey, size_t kn) {
  {PAD printf("Round Key:\n");showStateWithMoreIndent(roundKey);}
  for (size_t i = 0; i < kn; i++)
    state[i] ^= roundKey[i];
}

void subBytes (byte* state) {
  for (short i = 0; i < 16; i++)
    state[i] = s[state[i]];
}

#define SHIFTED_GET(X) getByteFromState(state, row, ((X)+row)%4)
void shiftRows (byte* state) {
  for (short row = 1; row < 4; row++) {
    byte t0 = SHIFTED_GET(0),
         t1 = SHIFTED_GET(1),
         t2 = SHIFTED_GET(2),
         t3 = SHIFTED_GET(3);
    setByteInState(state, row, 0, t0);
    setByteInState(state, row, 1, t1);
    setByteInState(state, row, 2, t2);
    setByteInState(state, row, 3, t3);
  }
}

void mixColumn (byte* state, short col) {
  //Implemented from the following reference: https://en.wikipedia.org/wiki/Rijndael_mix_columns
  /*
    b_0 = 2a_0 + 3a_1 + 1a_2 + 1a_3
    b_1 = 1a_0 + 2a_1 + 3a_2 + 1a_3
    b_2 = 1a_0 + 1a_1 + 2a_2 + 3a_3
    b_3 = 3a_0 + 1a_1 + 1a_2 + 2a_3
  */
  byte a0 = state[(col*4)+0],
       a1 = state[(col*4)+1],
       a2 = state[(col*4)+2],
       a3 = state[(col*4)+3];
  
  // Multiply by 2 -> single shift left and Xor with 0xff iif the high bit is
  //   set prior to shifting.
  // Multiply by 3 -> multiply by 2 and Xor with original value.
  
  byte h0 = (a0 >> 7)?0xff:0x00, //High bit set for byte in row 0?
       h1 = (a1 >> 7)?0xff:0x00, //etc.
       h2 = (a2 >> 7)?0xff:0x00,
       h3 = (a3 >> 7)?0xff:0x00;
  
  byte _1a_0 = a0,
       _2a_0 = (a0 << 1) ^ (0x1b & h0),
       _3a_0 = _1a_0 ^ _2a_0,
       _1a_1 = a1,
       _2a_1 = (a1 << 1) ^ (0x1b & h1),
       _3a_1 = _1a_1 ^ _2a_1,
       _1a_2 = a2,
       _2a_2 = (a2 << 1) ^ (0x1b & h2),
       _3a_2 = _1a_2 ^ _2a_2,
       _1a_3 = a3,
       _2a_3 = (a3 << 1) ^ (0x1b & h3),
       _3a_3 = _1a_3 ^ _2a_3;
  
  //Addition is Xor in Rijndael's Galois field.
  byte b0 = _2a_0 ^ _3a_1 ^ _1a_2 ^ _1a_3,
       b1 = _1a_0 ^ _2a_1 ^ _3a_2 ^ _1a_3,
       b2 = _1a_0 ^ _1a_1 ^ _2a_2 ^ _3a_3,
       b3 = _3a_0 ^ _1a_1 ^ _1a_2 ^ _2a_3;
  
  //Mutate state
  setByteInState(state, 0, col, b0);
  setByteInState(state, 1, col, b1);
  setByteInState(state, 2, col, b2);
  setByteInState(state, 3, col, b3);
}

void mixColumns (byte* state) {
  for (short i = 0; i < 4; i++)
    mixColumn(state, i);
}

byte* aes_block_encrypt (const byte* block_in, const byte* key, size_t kn, bool log) {
  //Implemented from the following reference: http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf
  assert(kn*8 == 128 || kn*8 == 192 || kn*8 == 256);
  int rounds = ((kn*8)==128)?10:(((kn*8)==192)?12:14);
  
  //Malloc the state, and initalize it with the plaintext block
  byte* state = (byte*)malloc(sizeof(byte)*16);
  memcpy(state, block_in, sizeof(byte)*16);
  if (log) {PAD printf("Added plaintext block:\n");showStateWithMoreIndent(state);}
  
  //Derive round keys and add the first round key in the initial round
  byte* keySchedule = expandKey(key, kn);
  addRoundKey(state, keySchedule+0, kn);
  if (log) {PAD printf("Added round key:\n");showStateWithMoreIndent(state);}
  
  //Perform all rounds, including final round
  for (unsigned short round = 0; round < rounds; round++) {
    if (log) {PAD printf("Round %d/%d\n", round+1, rounds);}
    indent++;
    if (log) {PAD printf("Initial state:\n");showStateWithMoreIndent(state);}
    subBytes(state);
    if (log) {PAD printf("After SubBytes:\n");showStateWithMoreIndent(state);}
    shiftRows(state);
    if (log) {PAD printf("After ShiftRows:\n");showStateWithMoreIndent(state);}
    if (round!=(rounds-1)) {
      mixColumns(state);
      if (log) {PAD printf("After mixColumns:\n");showStateWithMoreIndent(state);}
    }
    addRoundKey(state, keySchedule+((round+1)*kn), kn);
    if (log) {PAD printf("Adter addRoundKey:\n");showStateWithMoreIndent(state);}
    indent--;
  }
  
  free(keySchedule);
  return state;
}

byte* aes_ecb_encrypt(const byte* input, size_t in, const byte* key, size_t kn, bool log, size_t* outn) {
  assert((in%16) == 0); //TODO implement padding
  *outn = in; //Since we don't pad the size is the same
  size_t blocks = in/16;
  byte* ciphertext = (byte*)malloc(sizeof(byte)*16*blocks);
  indent++;
  for (size_t block = 0; block < blocks; block++) {
    if (log) {PAD printf("Block %zu/%zu\n", block+1, blocks);}
    indent++;
    byte* encipheredBlock = aes_block_encrypt(input+(block*16), key, kn, log);
    memcpy(ciphertext+(block*16), encipheredBlock, 16);
    free(encipheredBlock);
    indent--;
  }
  indent--;
  return ciphertext;
}

byte* aes_ecb_decrypt(const byte* input, size_t in, const byte* key, size_t kn, bool log, size_t* outn) {
  //TODO implement AES ECB decryption
  assert(0);
}
